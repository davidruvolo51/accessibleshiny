# The datatable function uses several subfunctions--using
# functions from purrr, rlang, and htmltools---to generate
# the html markup from an r data object. The parent function
# `datatable` passes input data to two secondary functions
# `thead` and `tbody` which are responsible for generating
# the table <thead> and <tbody> markup. The `thead` function
# is a bit simpler as a single row of cells is required. This
# function supports single row headers as dynamically generating
# multi-column headers and ensuring they are accessible is a
# bit more challenging. Optional arguements are passed to an
# additional secondary function `validate_props`, which is used
# in the lower-level functions. The `tbody` function generates
# the html markup for a the <tbody> element. This function is
# split into several hierachical functions. This is required
# as the markup needs to be generated by rows and columns. The
# `tbody` function passes input data to `tbody_rows` which
# returns a `<tr>` element for each row in the dataset and
# wrap all rows into `<tbody>`. The `tbody_rows` function
# generates the cell markup `<td>` for each column in the row.
# Data is based to the `tbody_cells` function that returns
# the cell markup based on user defined options. CSS classes
# and other attributes are generated using the `set_cell_attributes`
# function for customizing table formating through CSS.
# Nest functions in a list
datatable_helpers <- list()

# set_cell_attributes
# This function generates cell-level attributes based on a
# given data point. Two input arguments are required: index
# and value. The index is a counter that represents the column
# index. This is used to generate the css classes ".column-1".
# The data point is passed into the value argument. The returned
# object is a list that is used to add attributes to the cell.
datatable_helpers$set_cell_attributes <- function(index, value) {
    # set css classes based on class of value
    value_class <- class(value)
    attr <- list(
        class = paste0("datatype-", tolower(value_class)),
        "data-value" = ""
    )

    # class === numeric
    if (value_class == "numeric") {
        if (value > 0) {
            attr$class <- "datatype-numeric value-positive"
            attr$`data-value` <- value
        }
        if (value < 0) {
            attr$class <- "datatype-numeric value-negative"
            attr$`data-value` <- value
        }
        if (value == 0) {
            attr$class <- "datatype-numeric value-zero"
            attr$`data-value` <- value
        }
    }

    # class === bool
    if (value_class == "logical") {
        # true
        if (value) {
            attr$class <- "datatype-logical value-true"
            attr$`data-value` <- value
        }

        # false
        if (!value) {
            attr$class <- "datatype-logical value-false"
            attr$`data-value` <- value
        }
    }

    # update css with index
    attr$class <- paste0("column-", index, " ", attr$class)
    return(attr)
}


# tbody_cells
# This function generates the cell markup for the current row
# based on user defined options. Passed on the options, the
# returned cell may have an span for responsive layouts, a custom
# data attribute for selecting cells in css, and classnames based on
# the data type and column index. Cells may also be returned as a
# row header if the option is TRUE.
datatable_helpers$tbody_cells <- function(..., options) {
    args <- list2(...)
    index <- 1
    cells <- imap(args, function(d, .x) {

        # coerce column names to char
        colname <- as.character(.x)

        # Is the option htmlEscape TRUE?
        if (!options$html_escape) {
            cell_value <- HTML(d)
        }

        if (options$html_escape) {
            cell_value <- htmlEscape(d)
        }

        # Is the option row_headers set to TRUE
        # and is the current column index 1?
        if (options$`row_headers` && index == 1) {
            cell <- tags$th(cell_value)
            cell$attribs$role <- "rowheader"
        } else {
            cell <- tags$td(cell_value)
            cell$attribs$role <- "gridcell"
        }

        # Is the responsive option set to TRUE?
        if (options$responsive) {
            cell$children <- list(
                tags$span(
                    class = "hidden-colname",
                    `aria-hidden` = "true",
                    colname
                ),
                cell$children
            )
        }

        # run cell attributes and attached
        attr <- datatable_helpers$set_cell_attributes(index, d)
        cell$attribs$class <- attr[["class"]]
        if (attr[["data-value"]] != "") {
            cell$attribs$`data-value` <- attr[["data-value"]]
        }

        # index++
        index <<- index + 1
        return(cell)
    })
    return(cells)
}

# tbody_rows
# This function generates the markup for each row. User defined
# options are passed into the lower-level function `tbody_cells`.
datatable_helpers$tbody_rows <- function(..., options, colnames) {
    args <- list2(...)
    cells <- pmap(args, ~ datatable_helpers$tbody_cells(..., options = options))
    r <- tags$tr(cells, role = "row")
    return(r)
}

# tbody
# This function generates the html markup for the table body based
# on the input dataset. Markup is generated by rows and cells and
# returned in a <tbody> element.
datatable_helpers$tbody <- function(data, options) {
    body <- pmap(data, ~ datatable_helpers$tbody_rows(..., options = options))
    return(tags$tbody(role = "presentation", body))
}

# thead
# This function generates the html markup for the table header element
# based on user defined options.
datatable_helpers$thead <- function(data, options) {
    index <- 1
    headers <- map(names(data), function(c) {

        # coerce name as character
        col <- as.character(c)

        # define cell content based on options$html_escape
        if (!options$html_escape) {
            cell_value <- HTML(c)
        }
        if (options$html_escape) {
            cell_value <- htmlEscape(c)
        }

        # build cell <th> with attribs
        c <- tags$th(cell_value)
        c$attribs <- list(
            class = paste0(
                "column-", index,
                " colname-", col
            ),
            role = "columnheader",
            scope = "col"
        )
        index <<- index + 1
        return(c)
    })
    row <- tags$tr(role = "row", headers)
    return(tags$thead(role = "presentation", row))
}

# validate_props
# This function validates all optional arguments and returns
# all of them as a list object with table defaults or user
# defined options. The list object has two lists: attr and
# options. The `attr` list contains elements that are applied
# to the <table> element (e.g., id, class, etc.). The options
# list contains various logical arguments that are used to
# control the html markup (i.e., row headers, responsive, etc).
datatable_helpers$validate_props <- function(...) {
    # process three dots
    args <- list2(...)

    # set defaults
    attr <- list(
        role = "grid",
        class = "datatable row-highlighting caption-side-top"
    )
    options <- list(
        responsive = TRUE,
        row_headers = FALSE,
        html_escape = TRUE,
        caption_position = "top"
    )

    # evaluate args only if args exist
    if (length(args) > 0) {

        # add id and/or css
        if (!is.null(args$id)) attr$id <- args$id
        if (!is.null(args$class)) {
            attr$class <- paste0(attr$class, " ", args$class)
        }

        # process style args (i.e., update css)
        if (!is.null(args$style)) {

            # should row highlighting be added to the table?
            if (!is.null(args$style$row_highlighting)) {
                if (isFALSE(args$style$row_highlighting)) {
                    attr$class <- gsub(" row-highlighting", "", attr$class)
                }
            }

            # should caption position be set to below?
            if (!is.null(args$style$caption_below)) {
                if (isTRUE(args$style$caption_below)) {
                    attr$class <- gsub(
                        pattern = " caption-side-top",
                        replacement = " caption-side-bottom",
                        x = attr$class
                    )
                }
            }
        }

        # options
        if (!is.null(args$options)) {
            if (!is.null(args$options$row_headers)) {
                options$row_headers <- args$options$row_headers
            }
            if (!is.null(args$options$html_escape)) {
                options$html_escape <- args$options$html_escape
            }
            if (!is.null(args$options$responsive)) {
                options$responsive <- args$options$responsive
            }
        }
    }

    # return
    return(list(attribs = attr, options = options))
}
